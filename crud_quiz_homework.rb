
# Q1. Where are we instantiating instances of the Property class?
      On lines 6, 15, 24 of console.rb.
# Q2. Where are we defining the SQL that enables us to save the ruby Property object into the database?
      On lines 18-29 of property.rb.
# Q3. In console.rb, which lines modify the database?
      Lines 4, 13, 22, 31, 33.
# Q4. Why do we not define the id of a Property object at the point we instantiate it (‘new it up’)?
      Because we don't know what the id will be, sql allocates an id for us when the object is entered into the database.
# Q5. Where and how do we assign the id (that is generated by the database) to the ruby Property object?
      On line 32 of property.rb. We access the id by calling the id key on the first hash at index [0] and set it equal to @id.
# Q6. Why do we put a guard (an if clause) on the @id attribute in the constructor?
      To prevent id from being assigned 0.
# Q7. Why are some of the CRUD actions represented by instance methods, and others by class methods?
      Instance methods act on individual objects, Class methods act on the entire database.
# Q8. What type of data structure is returned by calls to db.exec_prepared()? In the save method, how do we access the id from the returned data structure?
      An array of hashes is returned. We access the id by calling the id key on the first hash at index [0].
# Q9. Why do we use prepared statements when performing database operations?
      To protect from running values that could damage the database through sql injection.
# Look at the find_by_id and find_by_address methods in the Property class.
# Q10. What do they take in as their arguments?
      find_by_address takes in an address as its argument, find_by_id takes in an id as its argument.
# Q11. What are their return values?
      find_by_address returns the property hash of the property with the address that is entered as the argument,
      find_by_id returns the property hash of the property with the id that is entered as the argument.
